[36m[[[ansible-1]]][0m
[31mFAILED...[0m
Time :  169.61 seconds

PASSED :  0 / 1
[36m[[[fastapi-1]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/fastapi-1/tests/test_jsonable_encoder.py'
Time :  0.0 seconds

[36m[[[fastapi-7]]][0m
[31mFAILED...[0m
Time :  6.31 seconds

[36m[[[fastapi-11]]][0m
If(
    test=Name(id='errors', ctx=Load()),
    body=[
        Raise(
            exc=Call(
                func=Name(id='RequestValidationError', ctx=Load()),
                args=[
                    Name(id='errors', ctx=Load())],
                keywords=[]))],
    orelse=[
        Assert(
            test=Compare(
                left=Attribute(
                    value=Name(id='dependant', ctx=Load()),
                    attr='call',
                    ctx=Load()),
                ops=[
                    IsNot()],
                comparators=[
                    Constant(value=None)]),
            msg=Constant(value='dependant.call must be a function')),
        If(
            test=Name(id='is_coroutine', ctx=Load()),
            body=[
                Assign(
                    targets=[
                        Name(id='raw_response', ctx=Store())],
                    value=Await(
                        value=Call(
                            func=Attribute(
                                value=Name(id='dependant', ctx=Load()),
                                attr='call',
                                ctx=Load()),
                            args=[],
                            keywords=[
                                keyword(
                                    value=Name(id='values', ctx=Load()))])))],
            orelse=[
                Assign(
                    targets=[
                        Name(id='raw_response', ctx=Store())],
                    value=Await(
                        value=Call(
                            func=Name(id='run_in_threadpool', ctx=Load()),
                            args=[
                                Attribute(
                                    value=Name(id='dependant', ctx=Load()),
                                    attr='call',
                                    ctx=Load())],
                            keywords=[
                                keyword(
                                    value=Name(id='values', ctx=Load()))])))]),
        If(
            test=Call(
                func=Name(id='isinstance', ctx=Load()),
                args=[
                    Name(id='raw_response', ctx=Load()),
                    Name(id='Response', ctx=Load())],
                keywords=[]),
            body=[
                If(
                    test=Compare(
                        left=Attribute(
                            value=Name(id='raw_response', ctx=Load()),
                            attr='background',
                            ctx=Load()),
                        ops=[
                            Is()],
                        comparators=[
                            Constant(value=None)]),
                    body=[
                        Assign(
                            targets=[
                                Attribute(
                                    value=Name(id='raw_response', ctx=Load()),
                                    attr='background',
                                    ctx=Store())],
                            value=Name(id='background_tasks', ctx=Load()))],
                    orelse=[]),
                Return(
                    value=Name(id='raw_response', ctx=Load()))],
            orelse=[]),
        Assign(
            targets=[
                Name(id='response_data', ctx=Store())],
            value=Call(
                func=Name(id='serialize_response', ctx=Load()),
                args=[],
                keywords=[
                    keyword(
                        arg='field',
                        value=Name(id='response_field', ctx=Load())),
                    keyword(
                        arg='response',
                        value=Name(id='raw_response', ctx=Load())),
                    keyword(
                        arg='include',
                        value=Name(id='response_model_include', ctx=Load())),
                    keyword(
                        arg='exclude',
                        value=Name(id='response_model_exclude', ctx=Load())),
                    keyword(
                        arg='by_alias',
                        value=Name(id='response_model_by_alias', ctx=Load())),
                    keyword(
                        arg='skip_defaults',
                        value=Name(id='response_model_skip_defaults', ctx=Load()))])),
        Assign(
            targets=[
                Name(id='response', ctx=Store())],
            value=Call(
                func=Name(id='response_class', ctx=Load()),
                args=[],
                keywords=[
                    keyword(
                        arg='content',
                        value=Name(id='response_data', ctx=Load())),
                    keyword(
                        arg='status_code',
                        value=Name(id='status_code', ctx=Load())),
                    keyword(
                        arg='background',
                        value=Name(id='background_tasks', ctx=Load()))])),
        Expr(
            value=Call(
                func=Attribute(
                    value=Attribute(
                        value=Attribute(
                            value=Name(id='response', ctx=Load()),
                            attr='headers',
                            ctx=Load()),
                        attr='raw',
                        ctx=Load()),
                    attr='extend',
                    ctx=Load()),
                args=[
                    Attribute(
                        value=Attribute(
                            value=Name(id='sub_response', ctx=Load()),
                            attr='headers',
                            ctx=Load()),
                        attr='raw',
                        ctx=Load())],
                keywords=[])),
        If(
            test=Attribute(
                value=Name(id='sub_response', ctx=Load()),
                attr='status_code',
                ctx=Load()),
            body=[
                Assign(
                    targets=[
                        Attribute(
                            value=Name(id='response', ctx=Load()),
                            attr='status_code',
                            ctx=Store())],
                    value=Attribute(
                        value=Name(id='sub_response', ctx=Load()),
                        attr='status_code',
                        ctx=Load()))],
            orelse=[]),
        Return(
            value=Name(id='response', ctx=Load()))])
[31mFAILED...[0m
Time :  36.27 seconds

PASSED :  0 / 3
[36m[[[keras-4]]][0m
[[[ Node ]]]
@interfaces.legacy_get_updates_support
def get_updates(self, loss, params):
    if isinstance(params, list):
        return params
    grads = self.optimizer.compute_gradients(loss, params)
    self.updates = [K.update_add(self.iterations, 1)]
    opt_update = self.optimizer.apply_gradients(grads, global_step=self.iterations)
    self.updates.append(opt_update)
    return self.updates
[32mPASSED![0m
Time :  65.2 seconds

[36m[[[keras-21]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/keras-21/tests/keras/test_callbacks.py'
Time :  0.02 seconds

[36m[[[keras-22]]][0m
If(
    test=Call(
        func=Name(id='isinstance', ctx=Load()),
        args=[
            Name(id='mask', ctx=Load()),
            Name(id='list', ctx=Load())],
        keywords=[]),
    body=[
        If(
            test=Call(
                func=Name(id='any', ctx=Load()),
                args=[
                    GeneratorExp(
                        elt=Compare(
                            left=Name(id='m', ctx=Load()),
                            ops=[
                                IsNot()],
                            comparators=[
                                Constant(value=None)]),
                        generators=[
                            comprehension(
                                target=Name(id='m', ctx=Store()),
                                iter=Name(id='mask', ctx=Load()),
                                ifs=[],
                                is_async=0)])],
                keywords=[]),
            body=[
                Raise(
                    exc=Call(
                        func=Name(id='TypeError', ctx=Load()),
                        args=[
                            BinOp(
                                left=BinOp(
                                    left=BinOp(
                                        left=Constant(value='Layer '),
                                        op=Add(),
                                        right=Attribute(
                                            value=Name(id='self', ctx=Load()),
                                            attr='name',
                                            ctx=Load())),
                                    op=Add(),
                                    right=Constant(value=' does not support masking, but was passed an input_mask: ')),
                                op=Add(),
                                right=Call(
                                    func=Name(id='str', ctx=Load()),
                                    args=[
                                        Name(id='mask', ctx=Load())],
                                    keywords=[]))],
                        keywords=[]))],
            orelse=[])],
    orelse=[
        Raise(
            exc=Call(
                func=Name(id='TypeError', ctx=Load()),
                args=[
                    BinOp(
                        left=BinOp(
                            left=BinOp(
                                left=Constant(value='Layer '),
                                op=Add(),
                                right=Attribute(
                                    value=Name(id='self', ctx=Load()),
                                    attr='name',
                                    ctx=Load())),
                            op=Add(),
                            right=Constant(value=' does not support masking, but was passed an input_mask: ')),
                        op=Add(),
                        right=Call(
                            func=Name(id='str', ctx=Load()),
                            args=[
                                Name(id='mask', ctx=Load())],
                            keywords=[]))],
                keywords=[]))])
Timeout!
Time :  3600.01 seconds

[36m[[[keras-34]]][0m
[[[ Node ]]]
while epoch < epochs:
    callbacks.on_epoch_begin(epoch)
    steps_done = 0
    batch_index = 0
    import keras
    if issubclass(output_generator.__class__, keras.utils.data_utils.Sequence):
        return self.history
    while steps_done < steps_per_epoch:
        generator_output = next(output_generator)
        if not hasattr(generator_output, '__len__'):
            raise ValueError('Output of generator should be a tuple `(x, y, sample_weight)` or `(x, y)`. Found: ' + str(generator_output))
        if len(generator_output) == 2:
            (x, y) = generator_output
            sample_weight = None
        elif len(generator_output) == 3:
            (x, y, sample_weight) = generator_output
        else:
            raise ValueError('Output of generator should be a tuple `(x, y, sample_weight)` or `(x, y)`. Found: ' + str(generator_output))
        batch_logs = {}
        if isinstance(x, list):
            batch_size = x[0].shape[0]
        elif isinstance(x, dict):
            batch_size = list(x.values())[0].shape[0]
        else:
            batch_size = x.shape[0]
        batch_logs['batch'] = batch_index
        batch_logs['size'] = batch_size
        callbacks.on_batch_begin(batch_index, batch_logs)
        outs = self.train_on_batch(x, y, sample_weight=sample_weight, class_weight=class_weight)
        if not isinstance(outs, list):
            outs = [outs]
        for (l, o) in zip(out_labels, outs):
            batch_logs[l] = o
        callbacks.on_batch_end(batch_index, batch_logs)
        batch_index += 1
        steps_done += 1
        if steps_done >= steps_per_epoch and do_validation:
            if val_gen:
                val_outs = self.evaluate_generator(validation_generator, validation_steps, workers=0)
            else:
                val_outs = self.evaluate(val_x, val_y, batch_size=batch_size, sample_weight=val_sample_weights, verbose=0)
            if not isinstance(val_outs, list):
                val_outs = [val_outs]
            for (l, o) in zip(out_labels, val_outs):
                epoch_logs['val_' + l] = o
        if callback_model.stop_training:
            break
    callbacks.on_epoch_end(epoch, epoch_logs)
    epoch += 1
    if callback_model.stop_training:
        break
[32mPASSED![0m
Time :  416.89 seconds

[36m[[[keras-39]]][0m
[[[ Node ]]]
if isinstance(self.target, int) and (not force and now - self.last_update < self.interval and (current < self.target)):
    return
[32mPASSED![0m
Time :  8.01 seconds

PASSED :  3 / 5
[36m[[[luigi-3]]][0m
[[[ Node ]]]
return tuple((x if isinstance(x, int) else tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict)))
[32mPASSED![0m
Time :  54.3 seconds

[36m[[[luigi-4]]][0m
[[[ Node ]]]
def copy(self, cursor, f):
    """
        Defines copying from s3 into redshift.

        If both key-based and role-based credentials are provided, role-based will be used.
        """
    logger.info('Inserting file: %s', f)
    colnames = ''
    if self.columns and len(self.columns) > 0:
        colnames = ','.join([x[0] for x in self.columns])
        colnames = '({})'.format(colnames)
    cursor.execute("\n         COPY {table} {colnames} from '{source}'\n         CREDENTIALS '{creds}'\n         {options}\n         ;".format(table=self.table, colnames=colnames, source=f, creds=self._credentials(), options=self.copy_options))
[32mPASSED![0m
Time :  109.04 seconds

[36m[[[luigi-6]]][0m
[31mFAILED...[0m
Time :  144.54 seconds

[36m[[[luigi-14]]][0m
[[[ Node ]]]
def has_excessive_failures(self):
    if self.failures.first_failure_time is not None and self.disable_hard_timeout:
        if time.time() >= self.failures.first_failure_time + self.disable_hard_timeout:
            return True
    if self.disable_failures and self.failures.num_failures() >= self.disable_failures:
        return True
    return False
[32mPASSED![0m
Time :  4.03 seconds

[36m[[[luigi-22]]][0m
[[[ Node ]]]
if isinstance(self.last_active, int) and self.last_active + config.worker_disconnect_delay < time.time():
    return True
[32mPASSED![0m
Time :  4.19 seconds

[36m[[[luigi-25]]][0m
[[[ Node ]]]
path = self.s3_load_path
[32mPASSED![0m
Time :  2.93 seconds

[36m[[[luigi-26]]][0m
[[[ Node ]]]
if not job.jar() or not os.path.exists(job.jar()):
    if not callable(job.jar):
        logger.error("Can't find jar: %s, full path %s", job.jar(), os.path.abspath(job.jar()))
    raise HadoopJarJobError('job jar does not exist')
[32mPASSED![0m
Time :  36.0 seconds

PASSED :  6 / 7
[36m[[[matplotlib-15]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/matplotlib-15/lib/matplotlib/tests/test_colors.py'
Time :  0.0 seconds

PASSED :  0 / 1
[36m[[[pandas-12]]][0m
If(
    test=Call(
        func=Attribute(
            value=Call(
                func=Name(id='notna', ctx=Load()),
                args=[
                    Name(id='mat', ctx=Load())],
                keywords=[]),
            attr='all',
            ctx=Load()),
        args=[],
        keywords=[]),
    body=[
        If(
            test=BoolOp(
                op=And(),
                values=[
                    Compare(
                        left=Name(id='min_periods', ctx=Load()),
                        ops=[
                            IsNot()],
                        comparators=[
                            Constant(value=None)]),
                    Compare(
                        left=Name(id='min_periods', ctx=Load()),
                        ops=[
                            Gt()],
                        comparators=[
                            Call(
                                func=Name(id='len', ctx=Load()),
                                args=[
                                    Name(id='mat', ctx=Load())],
                                keywords=[])])]),
            body=[
                Assign(
                    targets=[
                        Name(id='baseCov', ctx=Store())],
                    value=Call(
                        func=Attribute(
                            value=Name(id='np', ctx=Load()),
                            attr='empty',
                            ctx=Load()),
                        args=[
                            Tuple(
                                elts=[
                                    Subscript(
                                        value=Attribute(
                                            value=Name(id='mat', ctx=Load()),
                                            attr='shape',
                                            ctx=Load()),
                                        slice=Constant(value=1),
                                        ctx=Load()),
                                    Subscript(
                                        value=Attribute(
                                            value=Name(id='mat', ctx=Load()),
                                            attr='shape',
                                            ctx=Load()),
                                        slice=Constant(value=1),
                                        ctx=Load())],
                                ctx=Load())],
                        keywords=[])),
                Expr(
                    value=Call(
                        func=Attribute(
                            value=Name(id='baseCov', ctx=Load()),
                            attr='fill',
                            ctx=Load()),
                        args=[
                            Attribute(
                                value=Name(id='np', ctx=Load()),
                                attr='nan',
                                ctx=Load())],
                        keywords=[]))],
            orelse=[
                Assign(
                    targets=[
                        Name(id='baseCov', ctx=Store())],
                    value=Call(
                        func=Attribute(
                            value=Name(id='np', ctx=Load()),
                            attr='cov',
                            ctx=Load()),
                        args=[
                            Attribute(
                                value=Name(id='mat', ctx=Load()),
                                attr='T',
                                ctx=Load())],
                        keywords=[]))]),
        Assign(
            targets=[
                Name(id='baseCov', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Name(id='baseCov', ctx=Load()),
                    attr='reshape',
                    ctx=Load()),
                args=[
                    Tuple(
                        elts=[
                            Call(
                                func=Name(id='len', ctx=Load()),
                                args=[
                                    Name(id='cols', ctx=Load())],
                                keywords=[]),
                            Call(
                                func=Name(id='len', ctx=Load()),
                                args=[
                                    Name(id='cols', ctx=Load())],
                                keywords=[])],
                        ctx=Load())],
                keywords=[]))],
    orelse=[
        Assign(
            targets=[
                Name(id='baseCov', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Name(id='libalgos', ctx=Load()),
                    attr='nancorr',
                    ctx=Load()),
                args=[
                    Call(
                        func=Name(id='ensure_float64', ctx=Load()),
                        args=[
                            Name(id='mat', ctx=Load())],
                        keywords=[])],
                keywords=[
                    keyword(
                        arg='cov',
                        value=Constant(value=True)),
                    keyword(
                        arg='minp',
                        value=Name(id='min_periods', ctx=Load()))]))])
[31mFAILED...[0m
Time :  220.09 seconds

[36m[[[pandas-13]]][0m
If(
    test=Name(id='old', ctx=Load()),
    body=[
        Assign(
            targets=[
                Name(id='vec', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Name(id='libmissing', ctx=Load()),
                    attr='isnaobj_old',
                    ctx=Load()),
                args=[
                    Call(
                        func=Attribute(
                            value=Name(id='values', ctx=Load()),
                            attr='ravel',
                            ctx=Load()),
                        args=[],
                        keywords=[])],
                keywords=[]))],
    orelse=[
        Assign(
            targets=[
                Name(id='vec', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Name(id='libmissing', ctx=Load()),
                    attr='isnaobj',
                    ctx=Load()),
                args=[
                    Call(
                        func=Attribute(
                            value=Name(id='values', ctx=Load()),
                            attr='ravel',
                            ctx=Load()),
                        args=[],
                        keywords=[])],
                keywords=[]))])
[31mFAILED...[0m
Time :  1324.68 seconds

[36m[[[pandas-30]]][0m
[[[ Node ]]]
try:
    new_data = to_datetime(new_data, errors='raise', unit=date_unit)
except (ValueError, OverflowError):
    continue
except TypeError:
    continue
[32mPASSED![0m
Time :  10.99 seconds

[36m[[[pandas-31]]][0m
If(
    test=Name(id='needs_ngroups', ctx=Load()),
    body=[
        Assign(
            targets=[
                Name(id='func', ctx=Store())],
            value=Call(
                func=Name(id='partial', ctx=Load()),
                args=[
                    Name(id='func', ctx=Load()),
                    Name(id='ngroups', ctx=Load())],
                keywords=[]))],
    orelse=[])
[31mFAILED...[0m
Time :  2718.5 seconds

[36m[[[pandas-36]]][0m
[[[ Node ]]]
if isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass, ABCExtensionArray)):
    import numpy
    if not (isinstance(obj, numpy.ndarray) and numpy.issubdtype(obj.dtype, numpy.float)):
        return _isna_ndarraylike_old(np.asarray(obj, dtype=object))
    return _isna_ndarraylike_old(obj)
elif isinstance(obj, ABCDataFrame):
    return obj.isna()
elif isinstance(obj, list):
    return _isna_ndarraylike_old(np.asarray(obj, dtype=object))
elif hasattr(obj, '__array__'):
    return _isna_ndarraylike_old(np.asarray(obj))
else:
    return obj is None
[32mPASSED![0m
Time :  76.54 seconds

[36m[[[pandas-48]]][0m
[[[ Node ]]]
try:
    result = type(block.values)._from_sequence(result.ravel(), dtype=block.values.dtype)
except ValueError:
    result = result.reshape(1, -1)
except TypeError:
    result = result.reshape(1, -1)
[32mPASSED![0m
Time :  60.12 seconds

[36m[[[pandas-49]]][0m
[[[ Node ]]]
def rep(x, r):
    import pandas
    if not isinstance(x, pandas._libs.missing.NAType):
        try:
            return bytes.__mul__(x, r)
        except TypeError:
            return str.__mul__(x, r)
[32mPASSED![0m
Time :  13.84 seconds

[36m[[[pandas-51]]][0m
[[[ Node ]]]
if not self.is_unique or not other.is_unique:
    import pandas
    if not isinstance(self, pandas.core.indexes.category.CategoricalIndex):
        if self.is_monotonic and other.is_monotonic:
            return self._join_monotonic(other, how=how, return_indexers=return_indexers)
        else:
            return self._join_non_unique(other, how=how, return_indexers=return_indexers)
elif self.is_monotonic and other.is_monotonic:
    try:
        return self._join_monotonic(other, how=how, return_indexers=return_indexers)
    except TypeError:
        pass
[32mPASSED![0m
Time :  8.39 seconds

[36m[[[pandas-53]]][0m
If(
    test=UnaryOp(
        op=Not(),
        operand=Call(
            func=Attribute(
                value=Name(id='self', ctx=Load()),
                attr='holds_integer',
                ctx=Load()),
            args=[],
            keywords=[])),
    body=[
        Expr(
            value=Call(
                func=Attribute(
                    value=Name(id='self', ctx=Load()),
                    attr='_invalid_indexer',
                    ctx=Load()),
                args=[
                    Constant(value='label'),
                    Name(id='key', ctx=Load())],
                keywords=[]))],
    orelse=[])
[[[ Node ]]]
if kind == 'loc' and is_integer(key):
    import pandas
    if not isinstance(self, pandas.core.indexes.base.Index):
        if not self.holds_integer():
            self._invalid_indexer('label', key)
[32mPASSED![0m
Time :  73.05 seconds

[36m[[[pandas-57]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/pandas-57/pandas/tests/arrays/categorical/test_replace.py'
Time :  0.26 seconds

[36m[[[pandas-71]]][0m
If(
    test=BoolOp(
        op=And(),
        values=[
            Compare(
                left=Call(
                    func=Name(id='len', ctx=Load()),
                    args=[
                        Name(id='unique_bins', ctx=Load())],
                    keywords=[]),
                ops=[
                    Lt()],
                comparators=[
                    Call(
                        func=Name(id='len', ctx=Load()),
                        args=[
                            Name(id='bins', ctx=Load())],
                        keywords=[])]),
            Compare(
                left=Call(
                    func=Name(id='len', ctx=Load()),
                    args=[
                        Name(id='bins', ctx=Load())],
                    keywords=[]),
                ops=[
                    NotEq()],
                comparators=[
                    Constant(value=2)])]),
    body=[
        If(
            test=Compare(
                left=Name(id='duplicates', ctx=Load()),
                ops=[
                    Eq()],
                comparators=[
                    Constant(value='raise')]),
            body=[
                Raise(
                    exc=Call(
                        func=Name(id='ValueError', ctx=Load()),
                        args=[
                            JoinedStr(
                                values=[
                                    Constant(value='Bin edges must be unique: '),
                                    FormattedValue(
                                        value=Call(
                                            func=Name(id='repr', ctx=Load()),
                                            args=[
                                                Name(id='bins', ctx=Load())],
                                            keywords=[]),
                                        conversion=-1),
                                    Constant(value=".\nYou can drop duplicate edges by setting the 'duplicates' kwarg")])],
                        keywords=[]))],
            orelse=[
                Assign(
                    targets=[
                        Name(id='bins', ctx=Store())],
                    value=Name(id='unique_bins', ctx=Load()))])],
    orelse=[])
[31mFAILED...[0m
Time :  3035.0 seconds

[36m[[[pandas-72]]][0m
If(
    test=BoolOp(
        op=And(),
        values=[
            Call(
                func=Name(id='len', ctx=Load()),
                args=[
                    Attribute(
                        value=Name(id='arr_value', ctx=Load()),
                        attr='shape',
                        ctx=Load())],
                keywords=[]),
            Compare(
                left=Subscript(
                    value=Attribute(
                        value=Name(id='arr_value', ctx=Load()),
                        attr='shape',
                        ctx=Load()),
                    slice=Constant(value=0),
                    ctx=Load()),
                ops=[
                    Eq()],
                comparators=[
                    Subscript(
                        value=Attribute(
                            value=Name(id='values', ctx=Load()),
                            attr='shape',
                            ctx=Load()),
                        slice=Constant(value=0),
                        ctx=Load())]),
            Compare(
                left=Attribute(
                    value=Name(id='arr_value', ctx=Load()),
                    attr='size',
                    ctx=Load()),
                ops=[
                    Eq()],
                comparators=[
                    Attribute(
                        value=Name(id='values', ctx=Load()),
                        attr='size',
                        ctx=Load())])]),
    body=[
        Assign(
            targets=[
                Subscript(
                    value=Name(id='values', ctx=Load()),
                    slice=Name(id='indexer', ctx=Load()),
                    ctx=Store())],
            value=Name(id='value', ctx=Load())),
        Try(
            body=[
                Assign(
                    targets=[
                        Name(id='values', ctx=Store())],
                    value=Call(
                        func=Attribute(
                            value=Name(id='values', ctx=Load()),
                            attr='astype',
                            ctx=Load()),
                        args=[
                            Attribute(
                                value=Name(id='arr_value', ctx=Load()),
                                attr='dtype',
                                ctx=Load())],
                        keywords=[]))],
            handlers=[
                ExceptHandler(
                    type=Name(id='ValueError', ctx=Load()),
                    body=[
                        Pass()])],
            orelse=[],
            finalbody=[])],
    orelse=[
        Assign(
            targets=[
                Subscript(
                    value=Name(id='values', ctx=Load()),
                    slice=Name(id='indexer', ctx=Load()),
                    ctx=Store())],
            value=Name(id='value', ctx=Load()))])
Timeout!
Time :  3600.03 seconds

[36m[[[pandas-79]]][0m
Timeout!
Time :  3600.05 seconds

[36m[[[pandas-99]]][0m
If(
    test=Compare(
        left=Name(id='format', ctx=Load()),
        ops=[
            IsNot()],
        comparators=[
            Constant(value=None)]),
    body=[
        Raise(
            exc=Call(
                func=Name(id='ValueError', ctx=Load()),
                args=[
                    Constant(value='cannot specify both format and unit')],
                keywords=[]))],
    orelse=[])
[31mFAILED...[0m
Time :  3598.24 seconds

[36m[[[pandas-103]]][0m
If(
    test=BoolOp(
        op=Or(),
        values=[
            Compare(
                left=Name(id='freq', ctx=Load()),
                ops=[
                    IsNot()],
                comparators=[
                    Constant(value=None)]),
            Compare(
                left=Name(id='axis', ctx=Load()),
                ops=[
                    NotEq()],
                comparators=[
                    Constant(value=0)])]),
    body=[
        Return(
            value=Call(
                func=Attribute(
                    value=Name(id='self', ctx=Load()),
                    attr='apply',
                    ctx=Load()),
                args=[
                    Lambda(
                        args=arguments(
                            posonlyargs=[],
                            args=[
                                arg(arg='x')],
                            kwonlyargs=[],
                            kw_defaults=[],
                            defaults=[]),
                        body=Call(
                            func=Attribute(
                                value=Name(id='x', ctx=Load()),
                                attr='pct_change',
                                ctx=Load()),
                            args=[],
                            keywords=[
                                keyword(
                                    arg='periods',
                                    value=Name(id='periods', ctx=Load())),
                                keyword(
                                    arg='fill_method',
                                    value=Name(id='fill_method', ctx=Load())),
                                keyword(
                                    arg='limit',
                                    value=Name(id='limit', ctx=Load())),
                                keyword(
                                    arg='freq',
                                    value=Name(id='freq', ctx=Load())),
                                keyword(
                                    arg='axis',
                                    value=Name(id='axis', ctx=Load()))]))],
                keywords=[]))],
    orelse=[])
[31mFAILED...[0m
Time :  491.51 seconds

[36m[[[pandas-106]]][0m
If(
    test=Attribute(
        value=Name(id='self', ctx=Load()),
        attr='is_all_dates',
        ctx=Load()),
    body=[
        Assign(
            targets=[
                Name(id='tgt_values', ctx=Store())],
            value=Attribute(
                value=Name(id='target', ctx=Load()),
                attr='asi8',
                ctx=Load()))],
    orelse=[
        Assign(
            targets=[
                Name(id='tgt_values', ctx=Store())],
            value=Attribute(
                value=Name(id='target', ctx=Load()),
                attr='_ndarray_values',
                ctx=Load()))])
[[[ Node ]]]
@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)
def get_indexer_non_unique(self, target):
    target = ensure_index(target)
    (pself, ptarget) = self._maybe_promote(target)
    if pself is not self or ptarget is not target:
        return pself.get_indexer_non_unique(ptarget)
    if is_categorical(target):
        tgt_values = np.asarray(target)
    elif self.is_all_dates:
        tgt_values = target.asi8
    else:
        tgt_values = target._ndarray_values
    import pandas
    if isinstance(self, pandas.core.indexes.datetimes.DatetimeIndex):
        raise KeyError('not found in axis')
    (indexer, missing) = self._engine.get_indexer_non_unique(tgt_values)
    return (ensure_platform_int(indexer), missing)
[32mPASSED![0m
Time :  3459.68 seconds

[36m[[[pandas-110]]][0m
Timeout!
Time :  3600.07 seconds

[36m[[[pandas-111]]][0m
Timeout!
Time :  3600.09 seconds

[36m[[[pandas-112]]][0m
If(
    test=UnaryOp(
        op=Not(),
        operand=Call(
            func=Name(id='is_object_dtype', ctx=Load()),
            args=[
                Name(id='target_as_index', ctx=Load())],
            keywords=[])),
    body=[
        Assign(
            targets=[
                Name(id='target_as_index', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Name(id='self', ctx=Load()),
                    attr='_maybe_convert_i8',
                    ctx=Load()),
                args=[
                    Name(id='target_as_index', ctx=Load())],
                keywords=[])),
        Assign(
            targets=[
                Name(id='indexer', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Attribute(
                        value=Name(id='self', ctx=Load()),
                        attr='_engine',
                        ctx=Load()),
                    attr='get_indexer',
                    ctx=Load()),
                args=[
                    Attribute(
                        value=Name(id='target_as_index', ctx=Load()),
                        attr='values',
                        ctx=Load())],
                keywords=[]))],
    orelse=[
        Assign(
            targets=[
                Name(id='indexer', ctx=Store())],
            value=List(elts=[], ctx=Load())),
        For(
            target=Name(id='key', ctx=Store()),
            iter=Name(id='target_as_index', ctx=Load()),
            body=[
                Try(
                    body=[
                        Assign(
                            targets=[
                                Name(id='loc', ctx=Store())],
                            value=Call(
                                func=Attribute(
                                    value=Name(id='self', ctx=Load()),
                                    attr='get_loc',
                                    ctx=Load()),
                                args=[
                                    Name(id='key', ctx=Load())],
                                keywords=[]))],
                    handlers=[
                        ExceptHandler(
                            type=Name(id='KeyError', ctx=Load()),
                            body=[
                                Assign(
                                    targets=[
                                        Name(id='loc', ctx=Store())],
                                    value=UnaryOp(
                                        op=USub(),
                                        operand=Constant(value=1)))])],
                    orelse=[],
                    finalbody=[]),
                Expr(
                    value=Call(
                        func=Attribute(
                            value=Name(id='indexer', ctx=Load()),
                            attr='append',
                            ctx=Load()),
                        args=[
                            Name(id='loc', ctx=Load())],
                        keywords=[]))],
            orelse=[])])
[[[ Node ]]]
if isinstance(target_as_index, IntervalIndex):
    if self.equals(target_as_index):
        return np.arange(len(self), dtype='intp')
    common_subtype = find_common_type([self.dtype.subtype, target_as_index.dtype.subtype])
    if self.closed != target_as_index.closed or is_object_dtype(common_subtype):
        return np.repeat(np.intp(-1), len(target_as_index))
    left_indexer = self.left.get_indexer(target_as_index.left)
    right_indexer = self.right.get_indexer(target_as_index.right)
    indexer = np.where(left_indexer == right_indexer, left_indexer, -1)
else:
    import pandas
    if isinstance(self, pandas.core.indexes.interval.IntervalIndex):
        return np.arange(len(self), dtype='intp')
    if not is_object_dtype(target_as_index):
        target_as_index = self._maybe_convert_i8(target_as_index)
        indexer = self._engine.get_indexer(target_as_index.values)
    else:
        indexer = []
        for key in target_as_index:
            try:
                loc = self.get_loc(key)
            except KeyError:
                loc = -1
            indexer.append(loc)
[32mPASSED![0m
Time :  742.29 seconds

[36m[[[pandas-123]]][0m
Timeout!
Time :  3600.06 seconds

[36m[[[pandas-138]]][0m
[[[ Node ]]]
def quantile(x, q, interpolation_method='fraction'):
    """
    Compute sample quantile or quantiles of the input array. For example, q=0.5
    computes the median.

    The `interpolation_method` parameter supports three values, namely
    `fraction` (default), `lower` and `higher`. Interpolation is done only,
    if the desired quantile lies between two data points `i` and `j`. For
    `fraction`, the result is an interpolated value between `i` and `j`;
    for `lower`, the result is `i`, for `higher` the result is `j`.

    Parameters
    ----------
    x : ndarray
        Values from which to extract score.
    q : scalar or array
        Percentile at which to extract score.
    interpolation_method : {'fraction', 'lower', 'higher'}, optional
        This optional parameter specifies the interpolation method to use,
        when the desired quantile lies between two data points `i` and `j`:

        - fraction: `i + (j - i)*fraction`, where `fraction` is the
                    fractional part of the index surrounded by `i` and `j`.
        -lower: `i`.
        - higher: `j`.

    Returns
    -------
    score : float
        Score at percentile.

    Examples
    --------
    >>> from scipy import stats
    >>> a = np.arange(100)
    >>> stats.scoreatpercentile(a, 50)
    49.5

    """
    x = np.asarray(x)
    mask = isna(x)
    x = x[~mask]
    import numpy
    if not (numpy.issubdtype(x.dtype, numpy.number)):
        x = x.astype(numpy.number)
    values = np.sort(x)

    def _interpolate(a, b, fraction):
        """Returns the point at the given fraction between a and b, where
        'fraction' must be between 0 and 1.
        """
        return a + (b - a) * fraction

    def _get_score(at):
        if len(values) == 0:
            return np.nan
        idx = at * (len(values) - 1)
        if idx % 1 == 0:
            score = values[int(idx)]
        elif interpolation_method == 'fraction':
            score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)
        elif interpolation_method == 'lower':
            score = values[np.floor(idx)]
        elif interpolation_method == 'higher':
            score = values[np.ceil(idx)]
        else:
            raise ValueError("interpolation_method can only be 'fraction' , 'lower' or 'higher'")
        return score
    if is_scalar(q):
        return _get_score(q)
    else:
        q = np.asarray(q, np.float64)
        result = [_get_score(x) for x in q]
        result = np.array(result, dtype=np.float64)
        return result
[32mPASSED![0m
Time :  189.82 seconds

[36m[[[pandas-142]]][0m
[[[ Node ]]]
if is_timedelta:
    res = arr[res_indexer]
    lag = arr[lag_indexer]
    mask = (arr[res_indexer] == na) | (arr[lag_indexer] == na)
    if mask.any():
        res = res.copy()
        res[mask] = 0
        lag = lag.copy()
        lag[mask] = 0
    result = res - lag
    result[mask] = na
    out_arr[res_indexer] = result
else:
    import numpy
    if isinstance(arr, numpy.ndarray) and arr.dtype.type is numpy.bool_:
        out_arr[res_indexer] = arr[res_indexer] ^ arr[lag_indexer]
    else:
        out_arr[res_indexer] = arr[res_indexer] - arr[lag_indexer]
[32mPASSED![0m
Time :  1076.67 seconds

[36m[[[pandas-145]]][0m
If(
    test=Call(
        func=Attribute(
            value=Name(id='mask', ctx=Load()),
            attr='any',
            ctx=Load()),
        args=[],
        keywords=[]),
    body=[
        With(
            items=[
                withitem(
                    context_expr=Call(
                        func=Attribute(
                            value=Name(id='np', ctx=Load()),
                            attr='errstate',
                            ctx=Load()),
                        args=[],
                        keywords=[
                            keyword(
                                arg='all',
                                value=Constant(value='ignore'))]))],
            body=[
                Assign(
                    targets=[
                        Subscript(
                            value=Name(id='result', ctx=Load()),
                            slice=Name(id='mask', ctx=Load()),
                            ctx=Store())],
                    value=Call(
                        func=Name(id='op', ctx=Load()),
                        args=[
                            Subscript(
                                value=Name(id='xrav', ctx=Load()),
                                slice=Name(id='mask', ctx=Load()),
                                ctx=Load()),
                            Name(id='y', ctx=Load())],
                        keywords=[]))])],
    orelse=[])
Timeout!
Time :  3600.04 seconds

[36m[[[pandas-146]]][0m
If(
    test=Call(
        func=Attribute(
            value=Name(id='np', ctx=Load()),
            attr='any',
            ctx=Load()),
        args=[
            Compare(
                left=Name(id='left_value', ctx=Load()),
                ops=[
                    NotEq()],
                comparators=[
                    Name(id='right_value', ctx=Load())])],
        keywords=[]),
    body=[
        Return(
            value=Constant(value=False))],
    orelse=[])
[[[ Node ]]]
def array_equivalent(left, right, strict_nan=False):
    """
    True if two arrays, left and right, have equal non-NaN elements, and NaNs
    in corresponding locations.  False otherwise. It is assumed that left and
    right are NumPy arrays of the same dtype. The behavior of this function
    (particularly with respect to NaNs) is not defined if the dtypes are
    different.

    Parameters
    ----------
    left, right : ndarrays
    strict_nan : bool, default False
        If True, consider NaN and None to be different.

    Returns
    -------
    b : bool
        Returns True if the arrays are equivalent.

    Examples
    --------
    >>> array_equivalent(
    ...     np.array([1, 2, np.nan]),
    ...     np.array([1, 2, np.nan]))
    True
    >>> array_equivalent(
    ...     np.array([1, np.nan, 2]),
    ...     np.array([1, 2, np.nan]))
    False
    """
    (left, right) = (np.asarray(left), np.asarray(right))
    if left.shape != right.shape:
        return False
    try:
        if is_string_dtype(left) or is_string_dtype(right):
            if not strict_nan:
                return lib.array_equivalent_object(ensure_object(left.ravel()), ensure_object(right.ravel()))
            for (left_value, right_value) in zip(left, right):
                if left_value is NaT and right_value is not NaT:
                    return False
                elif isinstance(left_value, float) and np.isnan(left_value):
                    if not isinstance(right_value, float) or not np.isnan(right_value):
                        return False
                elif np.any(left_value != right_value):
                    return False
            return True
    except TypeError:
        return False
    if is_float_dtype(left) or is_complex_dtype(left):
        if not (np.prod(left.shape) and np.prod(right.shape)):
            return True
        return ((left == right) | isna(left) & isna(right)).all()
    elif is_datetimelike_v_numeric(left, right):
        return False
    elif needs_i8_conversion(left) and needs_i8_conversion(right):
        if not is_dtype_equal(left.dtype, right.dtype):
            return False
        left = left.view('i8')
        right = right.view('i8')
    if left.dtype.type is np.void or right.dtype.type is np.void:
        if left.dtype != right.dtype:
            return False
    return np.array_equal(left, right)
[32mPASSED![0m
Time :  486.59 seconds

[36m[[[pandas-152]]][0m
[[[ Node ]]]
to_concat = [self] + list(to_append)
[32mPASSED![0m
Time :  65.95 seconds

[36m[[[pandas-158]]][0m
Timeout!
Time :  3600.05 seconds

PASSED :  12 / 26
[36m[[[scrapy-1]]][0m
[[[ Node ]]]
for domain in allowed_domains:
    if domain and url_pattern.match(domain):
        message = 'allowed_domains accepts only domains, not URLs. Ignoring URL entry %s in allowed_domains.' % domain
        warnings.warn(message, URLWarning)
[32mPASSED![0m
Time :  2.2 seconds

[36m[[[scrapy-2]]][0m
[[[ Node ]]]
def __setitem__(self, key, value):
    if not isinstance(self.limit, type(None)):
        while len(self) >= self.limit:
            self.popitem(last=False)
    super(LocalCache, self).__setitem__(key, value)
[32mPASSED![0m
Time :  3.17 seconds

[36m[[[scrapy-8]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/scrapy-8/tests/test_item.py'
Time :  0.0 seconds

[36m[[[scrapy-17]]][0m
If(
    test=UnaryOp(
        op=Not(),
        operand=Call(
            func=Name(id='isinstance', ctx=Load()),
            args=[
                Name(id='text', ctx=Load()),
                Tuple(
                    elts=[
                        Name(id='bytes', ctx=Load()),
                        Attribute(
                            value=Name(id='six', ctx=Load()),
                            attr='text_type',
                            ctx=Load())],
                    ctx=Load())],
            keywords=[])),
    body=[
        Raise(
            exc=Call(
                func=Name(id='TypeError', ctx=Load()),
                args=[
                    BinOp(
                        left=Constant(value='to_unicode must receive a bytes, str or unicode object, got %s'),
                        op=Mod(),
                        right=Attribute(
                            value=Call(
                                func=Name(id='type', ctx=Load()),
                                args=[
                                    Name(id='text', ctx=Load())],
                                keywords=[]),
                            attr='__name__',
                            ctx=Load()))],
                keywords=[]))],
    orelse=[])
[[[ Node ]]]
return '%s %s' % (status, to_native_str('Unknown Status' if isinstance(http.RESPONSES.get(int(status)), type(None)) else http.RESPONSES.get(int(status))))
[32mPASSED![0m
Time :  72.74 seconds

[36m[[[scrapy-20]]][0m
If(
    test=Call(
        func=Attribute(
            value=Call(
                func=Attribute(
                    value=Name(id='line', ctx=Load()),
                    attr='lstrip',
                    ctx=Load()),
                args=[],
                keywords=[]),
            attr='startswith',
            ctx=Load()),
        args=[
            Constant(value='Sitemap:')],
        keywords=[]),
    body=[
        Expr(
            value=Yield(
                value=Call(
                    func=Attribute(
                        value=Subscript(
                            value=Call(
                                func=Attribute(
                                    value=Name(id='line', ctx=Load()),
                                    attr='split',
                                    ctx=Load()),
                                args=[
                                    Constant(value=':'),
                                    Constant(value=1)],
                                keywords=[]),
                            slice=Constant(value=1),
                            ctx=Load()),
                        attr='strip',
                        ctx=Load()),
                    args=[],
                    keywords=[])))],
    orelse=[])
[31mFAILED...[0m
Time :  49.01 seconds

[36m[[[scrapy-23]]][0m
If(
    test=Name(id='user', ctx=Load()),
    body=[
        Assign(
            targets=[
                Name(id='user_pass', ctx=Store())],
            value=BinOp(
                left=Constant(value='%s:%s'),
                op=Mod(),
                right=Tuple(
                    elts=[
                        Call(
                            func=Name(id='unquote', ctx=Load()),
                            args=[
                                Name(id='user', ctx=Load())],
                            keywords=[]),
                        Call(
                            func=Name(id='unquote', ctx=Load()),
                            args=[
                                Name(id='password', ctx=Load())],
                            keywords=[])],
                    ctx=Load()))),
        Assign(
            targets=[
                Name(id='creds', ctx=Store())],
            value=Call(
                func=Attribute(
                    value=Call(
                        func=Attribute(
                            value=Name(id='base64', ctx=Load()),
                            attr='b64encode',
                            ctx=Load()),
                        args=[
                            Name(id='user_pass', ctx=Load())],
                        keywords=[]),
                    attr='strip',
                    ctx=Load()),
                args=[],
                keywords=[]))],
    orelse=[
        Assign(
            targets=[
                Name(id='creds', ctx=Store())],
            value=Constant(value=None))])
[31mFAILED...[0m
Time :  100.69 seconds

[36m[[[scrapy-27]]][0m
[[[ Node ]]]
if response.status in [301, 307] and 'Location' in response.headers:
    import scrapy
    if isinstance(response.headers, scrapy.http.headers.Headers):
        return response
    redirected_url = urljoin(request.url, response.headers['location'])
    redirected = request.replace(url=redirected_url)
    return self._redirect(redirected, request, spider, response.status)
[32mPASSED![0m
Time :  6.05 seconds

[36m[[[scrapy-29]]][0m
[[[ Node ]]]
s += b'Host: ' + to_bytes('' if isinstance(parsed.hostname, type(None)) else parsed.hostname) + b'\r\n'
[32mPASSED![0m
Time :  2.57 seconds

[36m[[[scrapy-30]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/scrapy-30/tests/test_command_version.py'
Time :  1.44 seconds

[36m[[[scrapy-40]]][0m
[[[ Node ]]]
def _serialize_value(self, value):
    if isinstance(value, BaseItem):
        return self.export_item(value)
    if isinstance(value, dict):
        return dict(self._serialize_dict(value))
    if is_listlike(value):
        return [self._serialize_value(v) for v in value]
    try:
        if self.binary:
            return to_bytes(value, encoding=self.encoding)
        else:
            return to_unicode(value, encoding=self.encoding)
    except TypeError:
        return value
[32mPASSED![0m
Time :  24.48 seconds

PASSED :  6 / 10
[36m[[[spacy-5]]][0m
[[[ Node ]]]
def _pipe(docs, proc, kwargs):
    if isinstance(proc, list):
        return True
    kwargs = dict(kwargs)
    for arg in ['n_threads', 'batch_size']:
        if arg in kwargs:
            kwargs.pop(arg)
    for doc in docs:
        doc = proc(doc, **kwargs)
        yield doc
[32mPASSED![0m
Time :  17.96 seconds

PASSED :  1 / 1
[36m[[[tornado-7]]][0m
[33mERROR...[0m
  File "/home/wonseok/pyfix/my_tool/./test_main.py", line 227, in run
    works.work()
  File "/home/wonseok/pyfix/my_tool/work.py", line 600, in work
    neg_file_node = self.files[neg_filename]
'/home/wonseok/BugsInPy/benchmark/tornado-7/tornado/gen.py'
Time :  0.01 seconds

[36m[[[tornado-9]]][0m
[[[ Node ]]]
def url_concat(url, args):
    if isinstance(args, type(None)):
        return url
    'Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat("http://example.com/foo", dict(c="d"))\n    \'http://example.com/foo?c=d\'\n    >>> url_concat("http://example.com/foo?a=b", dict(c="d"))\n    \'http://example.com/foo?a=b&c=d\'\n    >>> url_concat("http://example.com/foo?a=b", [("c", "d"), ("c", "d2")])\n    \'http://example.com/foo?a=b&c=d&c=d2\'\n    '
    parsed_url = urlparse(url)
    if isinstance(args, dict):
        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)
        parsed_query.extend(args.items())
    elif isinstance(args, list) or isinstance(args, tuple):
        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)
        parsed_query.extend(args)
    else:
        err = "'args' parameter should be dict, list or tuple. Not {0}".format(type(args))
        raise TypeError(err)
    final_query = urlencode(parsed_query)
    url = urlunparse((parsed_url[0], parsed_url[1], parsed_url[2], parsed_url[3], final_query, parsed_url[5]))
    return url
[32mPASSED![0m
Time :  2.29 seconds

PASSED :  1 / 2
[36m[[[tqdm-9]]][0m
None Type Casting Other Type
Type :  range
None Type Casting Other Type
Type :  range
None Type Casting Other Type
Type :  range
None Type Casting Other Type
Type :  range
[31mFAILED...[0m
Time :  10.76 seconds

PASSED :  0 / 1
[36m[[[youtubedl-11]]][0m
[[[ Node ]]]
def str_to_int(int_str):
    """ A more relaxed version of int_or_none """
    if int_str is None:
        return None
    if isinstance(int_str, int):
        int_str = str(int_str)
    int_str = re.sub('[,\\.\\+]', '', int_str)
    return int(int_str)
[32mPASSED![0m
Time :  2.84 seconds

[36m[[[youtubedl-16]]][0m
[31mFAILED...[0m
Time :  1102.35 seconds

PASSED :  1 / 2
Total :  30 / 59
